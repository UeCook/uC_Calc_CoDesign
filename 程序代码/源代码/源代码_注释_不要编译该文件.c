#include <reg51.H>//8051单片机的寄存器定义头文件，专门用于8051 MCU。
#include<intrins.h>//内嵌函数库，提供一些与硬件直接相关的特殊操作，比如 _nop_() 函数用于产生空操作。
#include<stdio.h>//标准输入输出库，用于格式化输出或输入。
#include<string.h>//字符串操作库，提供 strcpy()、strlen() 等字符串操作函数。
#include<math.h>//数学库

sbit RS = P2^5; //数据/命令寄存器选择位，用于控制 LCD 是否接收数据（RS=1）或命令（RS=0）。
sbit RW = P2^6; //读写控制位，RW=1 表示读操作，RW=0 表示写操作。
sbit E  = P2^7; //使能引脚，控制 LCD 是否接受当前命令或数据。

#define Data P0//将 P0 端口定义为 Data。P0 用于连接 LCD 的数据端口。这样做的好处是，代码中可以用 Data 代表 P0 端口，便于阅读和理解。

//全局变量
float num1;
float num2;
char yun_flag = ' ';
char key_last;
char sqrt_flag;
unsigned long pos_flag = 1;
char neg_flag;
char data c_num1[15] = " ";
char data c_num2[15] = " ";
char error;
char len;
/*
num1 和 num2：两个浮点数。
yun_flag：用于标记运算符（如加减乘除等），默认为空格 ' '。
key_last：记录最后一次按键的编号，用于确定上次的按键操作。
sqrt_flag：标志平方根运算的状态，控制是否启用平方根计算功能。
pos_flag：一个 unsigned long 类型的变量，值为 1，可能用于标记操作数的精度或小数位处理。
neg_flag：标志负号状态，标记当前操作数是否为负数。
c_num1[15] 和 c_num2[15]：两个长度为 15 的字符数组，分别用于存储操作数 num1 和 num2 的字符串表示。
error：用于标记是否发生了错误，error 为 0 表示无错误，非 0 表示有错误发生。
len：用于存储当前输入的长度或字符串的有效长度。
*/

//==========================函数延迟模块：提供精确的时间延迟，确保硬件设备有足够的时间完成处理，保证操作的正确时序==========================//

void DelayUs(unsigned char us)//用于产生微秒级延迟，传入的参数 us 是一个 unsigned char 类型，用于指定延迟的微秒数
//unsigned char 是一种 8 位无符号字符数据类型，表示的值范围是从 0 到 255。它与 char 的区别在于，它只表示正数，不包括负数。
//在 C 语言中，参数声明必须位于函数定义中括号内，这会导致语法错误。
{
    unsigned char uscnt;//定义 8 位无符号变量 uscnt，用于计算延迟时间。
    uscnt = us >> 1;//us 右移一位，相当于除以 2，用这个值赋给 uscnt
    while (--uscnt)//空循环，uscnt 每次递减 1，当其减到 0 时退出循环。这个空循环的作用是通过消耗 CPU 的执行时间来实现延迟。
    { }
}

void DelayMs(unsigned char ms)//该函数用于产生毫秒级延迟。传入的参数 ms 是一个 unsigned char 类型，用于指定延迟的毫秒数
{
    while (--ms)// while 循环每次递减 ms，直到 ms 减为 0 。由于 ms 每次递减 1，函数会重复执行 ms 次
    {
        DelayUs(250);//循环内部调用 DelayUs(250) 四次，每次产生 250 微秒的延迟，四次加起来正好是 1 毫秒的延迟。
        DelayUs(250);
        DelayUs(250);
        DelayUs(250);
    }
}

//==========================LCD控制函数模块：包含初始化、数据写入、命令发送的功能，实现LCD显示屏显示==========================//

void WriteCommand(unsigned char c)//LCD写入命令函数，c 是一个 8 位无符号字符，表示需要发送到 LCD 的命令。
//函数将一个命令字节传输给 LCD，控制 LCD 执行特定操作（如清屏、设置显示位置）。它通过设置控制引脚和使用延迟来确保 LCD 能正确接收并处理命令。
{
    DelayMs(5);//写入前延时，保证信号稳定
    E = 0;//使能引脚 E 设置为低电平，准备向 LCD 传输数据。
    RS = 0;//指令寄存器选择引脚 RS 设为 0，表示要发送的是命令，而不是数据。
    RW = 0;//读写引脚 RW 设为 0，表示是写操作，而不是读操作。
    _nop_();//内联汇编指令，用于生成“无操作”指令，这是为了确保信号的稳定性，防止因时序问题引起错误。该指令是硬件级延迟，因此优先级最高。
    E = 1;//使能引脚设为高电平，表示开始传输命令。
    Data = c;//将传入的命令 c 发送到 Data 端口（LCD 数据总线）。
    E = 0;//结束操作，设为低电平。
}

void WriteData(unsigned char c)//向 LCD 发送一条数据（通常是显示的字符）。c 是一个 8 位无符号字符，表示需要发送到 LCD 的数据。
//每个函数都有自己的局部作用域，函数参数只在该函数内有效。所以它们彼此独立，并不会冲突或引发错误。在 WriteData 和 WriteCommand 函数中都定义了 unsigned char c 作为参数，这是完全合法的。
{
    DelayMs(5);//写入前延时，保证信号稳定
    E = 0;//使能引脚 E 设置为低电平，准备向 LCD 传输数据。
    RS = 1;//指令寄存器选择引脚 RS 设为 0，表示发送的是数据而不是命令。
    RW = 0;//读写引脚 RW 设为 0，表示是写操作，而不是读操作。
    _nop_();//同上
    E = 1;//开始传输数据
    Data = c;//Data = c 设置数据线的内容。
    E = 0;//结束操作，设为低电平。
    RS = 0;//把RS置零，在下一次操作时可以进行命令的传输（而不是数据）。
}
/*
如果我使用空函数void wait(void)来替代_nop_();是可行的吗？
不行。理由如下：

1.空函数没有延迟效果：
如果你定义一个空的 wait(void) 函数，比如：
void wait(void) 
    {
        // 空函数
    }
这个函数在运行时什么都不做，它只会被调用并立即返回，不会产生任何延迟。这和 _nop_(); 的作用不一样。

2.nop(); 是硬件级延迟：
_nop_(); 是一个汇编指令，执行时相当于一个 CPU 时钟周期的空操作。这个操作在时序敏感的硬件控制（如 LCD 显示屏）中，能够确保引脚状态或数据线有足够的时间稳定。
如果你用空的 wait(void) 函数替换 _nop_();，你将失去这个时序控制的精确性，而这可能导致设备无法正常工作，尤其是在高速操作下。

3.如果给wait(void)循环中加入延迟语句（例如下面的例子），这种基于循环的延迟不如_nop_()精确。延迟的具体时间取决于编译器优化、CPU 时钟频率等因素，因此不适合精确时序控制。
如果系统对时间控制要求较高（如控制 LCD、I2C 总线等），建议使用硬件支持的延迟或者精确的定时器，而不是简单的循环延迟。
void wait(void) 
{
    for (volatile int i = 0; i < 100; i++);//volatile 关键字告诉编译器不要优化掉这个空循环
}
*/

void InitLcd(void)//初始化LCD显示屏。按照标准的 LCD 初始化流程，逐步发送命令来设置显示屏的工作模式和功能。
{
    DelayMs(15);           // 延迟15毫秒，用来确保 LCD 在上电或复位后有足够的时间进入稳定状态。
    WriteCommand(0x38);    // 8位总线，2行显示，5x7点阵字符
    WriteCommand(0x38);    // 再次发送功能设定命令，确保显示正确初始化
    WriteCommand(0x38);    // 重复发送这个命令是标准的初始化步骤。LCD 初始化时要求功能设定命令发送多次，确保正确初始化。
    WriteCommand(0x06);    // 光标移动设置：每写入一个字符，光标右移，同时确保写入字符时，不会滚动整个显示屏。
    WriteCommand(0x0c);    // 显示控制：显示开启，光标关闭，无闪烁
    WriteCommand(0x01);    // 清屏，并将光标归位到左上角
}

//==========================显示字符串函数：在LCD屏幕上显示数字或者字符，控制字符或数字显示的位置==========================//

void ShowChar(unsigned char pos, unsigned char c)//在 LCD 的指定位置显示一个字符。
//定义两个变量 pos：显示字符的位置（地址）。c：要显示的字符。依旧使用 unsigned char 8 位无符号字符
//该函数的作用是把 scan(void) 函数获取的键位显示到LCD中
{
    unsigned char p;//定义一个 8 位无符号字符 p，用于存储计算出来的地址。
    if (pos >= 0x10)//如果 pos 大于或等于 0x10（LCD 的第 2 行起始位置），则将 pos 偏移 0xb0，指向 LCD 的第二行。
    {
        p = pos + 0xb0;
    }
    else//否则，pos 偏移 0x80，指向 LCD 的第一行。
    {
        p = pos + 0x80;
    }
    WriteCommand(p);//将计算好的地址 p 通过 WriteCommand 发送给 LCD，设置光标位置。
    WriteData(c);//使用 WriteData 在指定的位置显示字符 c。
}

void ShowString(unsigned char line, char *ptr)
//在 LCD 屏幕上显示一段字符串
//unsigned char line：指定显示的行号。通常用于控制 LCD 的行（如第 1 行或第 2 行）。
//char *ptr：字符指针，指向要显示的字符串。它通常是一个字符数组或字符串的地址，函数会逐个读取并显示。
//char *ptr：表示一个指向字符的指针，指向要显示的字符串。
//使用该函数是为了让单片机更好的处理带小数的数字，例如显示123.45等，这样可以大大节省单片机算力
{
    unsigned char l, i;//定义变量，保存显示字符串时在 LCD 上的起始地址，通过 line(l) 参数计算得出。i用于遍历字符串中的每个字符的循环计数器。
    l = line << 4;//将行号左移 4 位，相当于将 line 乘以 16，这样可以计算出字符串应该显示的起始地址。如果每行可以显示 16 个字符，左移 4 位可以准确计算出 LCD 的显示地址。
    for (i = 0; *(ptr + i) != '\0'; i++)
    //循环遍历字符指针 ptr 指向的字符串，直到遇到字符串的结束符 \0。
    //*(ptr + i) 用于获取字符串中的第 i 个字符。
    {
        ShowChar(l++, *(ptr + i));
    }
    //ShowChar() 函数用于在 LCD 的指定位置 l 显示单个字符 *(ptr + i)。
    //l++ 确保每次调用 ShowChar() 时，显示位置会自动移动到下一个位置。
}

//==========================按键扫描函数：实现对5×4矩阵键盘按下的按键进行扫描读取（以/* */解释）==========================//

char scan(void)
{
    char h_data, l_data, i, key_num;
    P2 = P2 & 0XE0;
    P1 = P1 | 0X0F;
    while ((P1 | 0xf0) == 0xff)
    {
        while ((P1 | 0xf0) == 0xff)
        { }
        DelayMs(10);
    }
    l_data = ~(P1 | 0xf0);
    P2 = P2 | 0X1F;
    P1 = P1 & 0XF0;
    h_data = ~(P2 | 0xe0);
    for (i = 0; i <= 4; i++)
    {
        if (h_data == 1)
        {
            break;
        }
        h_data = h_data >> 1;
    }
    h_data = i;
    for (i = 1; i <= 4; i++)
    {
        if (l_data == 1)
        {
            break;
        }
        l_data = l_data >> 1;
    }
    l_data = i;
    key_num = h_data * 4 + l_data;

    P2 = P2 & 0XE0;
    P1 = P1 | 0X0F;
    while ((P1 | 0xf0) != 0xff)
    {
        while ((P1 | 0xf0) != 0xff)
        {
        }
        DelayMs(10);
    }
    return key_num;
}
/*
scan(void) 函数的主要功能是扫描矩阵键盘，检测哪个按键被按下，并返回相应的按键编号。它通过硬件端口 P1 和 P2 实现行列扫描，结合消抖处理来确保检测的可靠性。

定义 char 变量 h_data, l_data, i, key_num。无参数输入，函数通过内部的端口和控制逻辑扫描键盘。
h_data：保存行扫描结果。
l_data：保存列扫描结果。
i：用于循环计数，帮助确定行和列的索引。
key_num：保存按键的最终编号，表示按键在矩阵中的位置。


行列初始化：
P2 = P2 & 0XE0;  保留 P2 高 3 位，清除低 5 位，用于行检测。
P1 = P1 | 0X0F;  P1 的低 4 位设置为 1，准备列检测。

等待按键按下：
while ((P1 | 0xf0) == 0xff);  等待按键按下，当所有列的状态为 1 时表示没有按键按下，循环继续。

列扫描：
l_data = ~(P1 | 0xf0);  读取列的状态，将其反转后存入 l_data，表示具体哪一列的按键被按下。
~ 按位取反（bitwise NOT）操作符。它用于将数值的每一位取反，即将二进制数中的 0 变为 1，1 变为 0。常用于信号检测操作。

行扫描：
P2 = P2 | 0X1F;  启用 P2 的低 5 位，用于行扫描。
P1 = P1 & 0XF0;  禁用 P1 的低 4 位，以便进行行检测。
h_data = ~(P2 | 0xe0);  通过读取 P2 的低 5 位，检测到被按下的行号。
&（按位与）操作:按位与操作符 & 用于将两个数的每一位进行比较，只有当两个对应位都是 1 时，结果才为 1，否则结果为 0。
|（按位或）操作:按位或操作符 | 用于将两个数的每一位进行比较，只要有一个对应位是 1，结果就为 1。

解析行号和列号：
使用两个 for 循环逐位右移 h_data 和 l_data，确定按键被按下的行和列号。找到行或列对应的值时跳出循环，并将索引赋值给 h_data 和 l_data。

计算按键编号：
key_num = h_data * 4 + l_data;  根据行和列号计算按键的编号，按键编号为 h_data * 4 + l_data，其中 h_data 表示行，l_data 表示列。

等待按键释放：
在返回按键编号之前，函数再次等待按键释放（即所有列返回高电平状态），以防止多次误触发。

返回按键编号：
函数将最终计算出的按键编号 key_num 返回。
*/

//==========================将浮点数转化为字符串函数：确保浮点数的显示只包含必要的信息，不浪费显示空间==========================//

void float_to_char(float a, char *p)
//将浮点数 a 转换为字符串并去除末尾不必要的零，最终以字符数组形式存储在指针 p 所指向的空间中。
//在LCD显示模块中，我们已经定义了void ShowString()显示函数，因此字符数组在存储后通过指针发送给LCD显示
//“去除末尾的零”意思是去掉float里面多余的零位，例如，123.000000 显示为 123，123.450000 显示为 123.45。
//float a 定义了要转换的浮点数，char *p 定义了转换后的数组。
{
    char i, flag, length;
    flag = 0;//定义flag=0，用来检测是否有小数点，若有则为1
    sprintf(p, "%f", a);//这里的 sprintf 函数将浮点数 a 转换为带小数点的字符串并存储在 p 所指向的字符数组中。
    length = strlen(p);
    for (i = 0; i < length; i++)//遍历字符串，检查是否有小数点。
    {
        if (*(p + i) == '.')
        {
            flag = 1;//如果存在小数点，将 flag 设为 1，标识有小数部分需要处理。
        }
    }
    if (flag == 1)//在上面的循环中，若出现了小数点则 flag = 1 ，所以该 if 语句的作用是检测到 flag 变量为 1 的时候则执行
    {
        for (i = length - 1; i >= 0; i--)
        //我们假设 flag == 1，此时进入去除末尾 0 的 for 循环
        //我们从字符串的最后一位（即末尾字符）开始向前遍历，i 代表当前遍历的位置。length - 1 是字符串的最后一个字符的索引。
        //逐字符向前检查字符串，目的是从末尾向前找到多余的 0 ，或者找到小数点并处理它。所以这条循环的本质是帮助我们定位需要删除的位置。
        //举第一个例子，假设我们处理的字符串是 "123.450000"
        //举第二个例子，假设我们处理的字符串是 "123.000000"
        {
            if (*(p + i) == '.')
            //检查当前字符是否是小数点
            //*(p + i) 它表示获取指针 p 所指向的字符串的第 i 个字符。
            //如果当前字符是小数点，说明我们已经处理完了所有需要删除的尾随 0，并且到了小数点的位置，例如例子二，循环遍历后发现最后一位为"."，因此做上标记“小数点之后都是0”。
            //在例子一中，因为"123.45"最后一位为"5"，因此不符合“当前字符是小数点”的设定，无法进入这个循环。
            {
                *(p + i) = '\0';
                //将小数点替换为字符串结束符 \0，从而删除小数点和小数点之后的所有字符。
                //此时传送下来的数组是"123.000000"，因为小数点之后没有有效的小数位了，所以小数点和0都会被删除，最终结果是 "123"。
                break;
                //break 终止 for 循环，因为此时不再需要继续检查字符串了。
            }
            if (*(p + i) != '0')
            //从数字小数部分末尾开始检测，跳过连续的0，直到遇到非0数字。
            //该逻辑的作用是，当遍历到一个非 0 的字符时，意味着从这个字符开始，尾部的零都需要删除。
            //在例子二中，因为上一个循环抛弃了"123.450000",因此进入这个循环。
            {
                *(p + i + 1) = '\0';
                //从数字小数部分末尾开始检测，跳过连续的0，直到遇到非0数字，那么将这个非 0 数字的后一个位置设置为字符串结束符 \0，从而去除它后面的所有零。
                //此时传送下来的数组是"123.450000"，因为最后一位非零数字为"5"，所以"5"之后的下一位都会被删除，最终结果是 "123.45"。
                break;
                //break 终止 for 循环，因为此时不再需要继续检查字符串了。
            }
        }
    }
}
/*
已知for (i = 0; i < length; i++)是遍历字符串，检查是否有小数点。那么循环下面的 if (*(p + i) == '.') 函数表示什么？
知识补充-指针和数组的关系：在 C 语言中，字符数组（如字符串）可以通过指针来访问。指针 p 指向一个字符数组的首地址，*(p + i) 表示通过指针 p 访问位置 i 处的字符。
代码中 p + i 的含义是将指针 p 向后移动 i 个位置，这相当于访问数组的第 i 个元素。
*(p + i) 表示获取指针 p 当前指向位置的字符值。
因此这条 if 语句的意思是：判断字符串 p 的第 i 个字符是否是小数点 '.'。
 *(p + i) == '.' 表示，如果当前字符等于 '.'，则进入 if 语句块。
换句话说，这一行代码是在遍历字符串的过程中，检查每个字符是否为小数点，用于判断字符串中是否存在小数点。
*/

//==========================显示内容更新模块函数：根据当前数值状态更新显示内容==========================//

void refresh(void)//根据当前数值状态更新显示内容（如 num1 和 num2），并处理小数点、负号、平方根符号等特殊情况，最终将结果显示在 LCD 上。
{
    char length, i, j;// length 用于存储字符数组的长度。i、j 作为循环计数器
    char dot;
    dot = 0;// dot 用于标记是否存在小数点，初始化为 0，表示没有小数点。

    float_to_char(num2, c_num2);//调用float_to_char()函数,将浮点数 num2 转换为字符串形式，并存储在字符数组 c_num2 中
    length = strlen(c_num2);//重新调用 strlen() 获取最新长度，确保后续的操作基于正确的长度。
    //strlen() 获取当前字符串 c_num2 的长度，并将其存储在变量 length 中，方便后续代码使用。它不会修改 c_num2 或直接存储任何新数据，而是返回 c_num2 的当前长度（不包括字符串结束符 \0）。
    for (i = 0, j = 0; i < length; i++)//遍历 c_num2 字符串，检查是否有小数点。
    {
        if (c_num2[i] == '.')//如果有小数点
        {
            dot = 1;//设置 dot = 1
        }
        if (dot == 1)//若 dot 绝对等于 1
        {
            j++;//同时 j 记录小数点后的字符数（包括小数点本身）。
        }
    }
    if (j < len)//对数据进行补零，如果小数点后的字符数少于要求的 len，需要进行补全操作。
    {
        if (dot == 1)//如果存在小数点，补全小数位至 len。在字符串后追加足够的 0 以保证小数点后的字符达到 len。
        {
            for (i = length; i < (length + len - j); i++)
            //初始化 i 的值为 length，当 i 小于 (length + len - j) 时，继续执行循环。否则，循环结束，每次循环结束时，i 增加 1。
            //在这里 len 是目标长度，j 是小数点后的字符数
            {
                c_num2[i] = '0';//补齐0
            }
            c_num2[i] = '\0';//补齐后截断
        }
        else//如果 不 存在小数点，则在字符串后追加小数点和足够的 0 以保证字符达到 len。
        {
            c_num2[length] = '.';//添加小数点
            if (len - j > 1)//检查是否需要补0
            {
                for (i = length + 1; i < (length + len - j); i++)
                {
                    c_num2[i] = '0';//补0
                }
            }
            c_num2[length + len - j] = '\0';//补0位置达到 len 后截断
        }
    }
    if (neg_flag == 1)//负号的处理，若neg_flag == 1，则表明需要处理负号
    {
        length = strlen(c_num2);//计算当前字符串 c_num2 的长度（不包括结束符 \0），并将其存储在变量 length 中。
        for (i = length - 1; i >= 0; i--)//从右向左遍历循环
        {
            c_num2[i + 1] = c_num2[i];//每次循环中，将 c_num2[i] 赋值给 c_num2[i + 1]，这就是字符串右移一位的过程。因为负号占一个显示位。
        }
        c_num2[length + 1] = '\0';//截断
        c_num2[0] = '-';//重新添加负号
    }//处理负数与计算无关。
    if (sqrt_flag == 1)//处理开根号，解释同上，略
    {
        length = strlen(c_num2);//计算数组长度
        for (i = length - 1; i >= 0; i--)
        {
            c_num2[i + 1] = c_num2[i];
        }
        c_num2[length + 1] = '\0';
        c_num2[0] = 0xe8;
    }//在处理开根号时，先将原始字符串 c_num2 右移一位，为在首部插入 0xe8 做准备。这与开根号的计算结果无关。

    if (error == 0)
    //在没有发生错误（error == 0）时，将浮点数 num1 转换为字符数组，并在液晶屏上显示两个数值和当前的运算符
    {
        float_to_char(num1, c_num1);//将浮点数转换为字符串显示，调用 float_to_char()
        WriteCommand(0x01);//发送清屏命令，确保显示区域被清空，为写入新数据做准备。
        ShowString(0, c_num1);//在显示器的第 0 行显示转换后的字符串。是上一次计算的结果或者当前的计算状态。
        ShowString(1, c_num2);//在第 1 行显示 c_num2，c_num2 是 num2 经过 float_to_char 函数处理后的字符串表示，即下一步操作输入的数字。
        ShowChar(15, yun_flag);//在第 0 行第 15 位显示 yun_flag，yun_flag 存储了当前的运算符（例如 +, -, *, /）。
    }
    else//如果发生了错误（error != 0），则清屏并显示 "error!!!" 提示信息。
    {
        WriteCommand(0x01);//清屏
        ShowString(0, "error!!!");//在屏幕的第 0 行显示错误提示 "error!!!"，以告知用户运算中出现了错误，比如除以零或负数开平方。
    }
}
/*
在void float_to_char()中已经去除了0，为什么在void refresh()中还要补0，这不会显得void float_to_char()很多余吗？

从表面上看，void float_to_char() 去除多余的 0，而 void refresh() 又在某些情况下补回 0，看似它们的操作互相抵消，可能会让人觉得 float_to_char() 的去零操作显得多余。但是，如果深入理解它们各自的用途和适用场景，就会明白两者其实是互补的，而不是多余的。

1. float_to_char() 的实际用途
float_to_char() 函数的设计目的是：
去掉无意义的尾部 0，使得浮点数的字符串表示更加紧凑和简洁。这样做可以节省显示空间，特别是在输出到串口、日志或保存为文件时，简化的数据更易读、易处理。
在某些场景下显示简化的浮点数：并不是所有场景都要求显示固定的小数位数。例如，科学计算器或日志系统往往会根据实际精度去掉无用的 0，以便更直接地反映有效数位。

2. refresh() 函数的补零操作
refresh() 函数的目的是：
在特定场景下，确保显示固定的小数位数，以保持输出结果的格式一致性。这在用户界面或金融应用中尤为重要。例如，金额通常需要显示两位小数，即使这些小数位是 0（例如 12.50 元，而不是 12.5 元），保持格式化对齐和数据的一致性是必要的。

3. 为什么两者并不冲突？
灵活性：float_to_char() 提供了一种灵活的方式去简化浮点数的表示。它去除无用的零，可以在某些场景下（如调试、输出到文件或控制台）更易读。在这些场景中，去掉不必要的零显得很有用。
适应不同的需求：refresh() 函数的补零操作是为特定的场景而设计的，通常是为了满足格式化显示的需求，尤其是在 UI 界面或特定业务场景中，数据需要保持固定的小数位数。而 float_to_char() 并没有考虑显示场景，只是负责将浮点数转换为更简洁的字符串形式。

4. 为什么 float_to_char() 并不多余？
多场景复用：float_to_char() 让程序具备了一种通用的能力，可以在不依赖于具体显示规则的前提下，将浮点数转换为简化的字符串形式。在不同的上下文中，这种简化的表示可能是首选。
refresh() 只在特定条件下补零：refresh() 并不是在所有情况下都补零，它只在需要保持固定小数位数的时候才执行补零操作。而且，float_to_char() 提供的简洁字符串有助于减少不必要的冗余信息，并且在很多情况下可以避免补零操作。


strlen() 是 C 标准库中的一个函数，用于计算一个以空字符（\0）结尾的字符串的长度，即字符串中字符的数量，但不包括字符串的结束符 \0。
函数原型：

#include <string.h>
size_t strlen(const char *str);

str：指向需要计算长度的字符串的指针。
返回值： size_t，表示字符串的长度（字符的个数，不包括终止符 \0）。
*/

//==========================数学运算函数：处理数字输入、运算符处理、退格、小数点、负号和开平方==========================//
/*
数学运算函数共有 operation(void) 8组，对应如下：

1. operation1(char keynum)
处理基本的数学运算（如 +, -, *, /）的逻辑。
判断当前运算符并执行相应的运算，如果发生错误（如除以零或负数开平方），设置 error 标志。
还负责更新 num1、num2 的值，并在运算后重置相关标志位。

2. operation2(char keynum)
处理数字输入。根据按键，更新 num2 的值，用户输入的数字会逐步加到 num2 上。
如果存在小数点，则 num2 会按照小数位进行更新（通过 pos_flag 控制）。

3. operation3(void)
处理小数点输入。如果按下小数点，更新 pos_flag，并设置 len 表示当前输入的小数长度。

4. operation4(void)
处理等号按键（确认运算）。类似于 operation1，负责执行数学运算，计算结果后将 num2 清零并重置标志位。

5. operation5(void)
处理清除操作。将所有变量（如 num1、num2、error 等）重置为初始状态，相当于用户按下了“清除”键。

6. operation6(void)
处理退格操作。从 num2 中删除最后输入的数字或小数部分，并更新显示。

7. operation7(void)
处理负号切换。当用户按下负号键时，切换 num2 的符号。

8. operation8(void)
处理平方根操作。按下开平方键时，切换 sqrt_flag，表示需要对 num2 进行平方根运算。
*/

void operation1(char keynum)
{
    if (key_last == 1)//判断上一个输入是否是一个数字。如果上一个输入是数字，则表示现在可以进行运算。
    {
        if (neg_flag == 1)//检查是否按下了负号键（由 operation7(void) 函数控制），如果按下了负号键，则将 num2 变为负数。
        {
            num2 = -num2;//将 num 取负
        }
        if (sqrt_flag == 1)//开平方处理，检查是否按下了平方根键
        {
            if (num2 >= 0)//判断 num2 是否为非负数，因为只能对非负数进行平方根操作
            {
                num2 = sqrt(num2);//如果 num2 非负，则对其进行平方根运算
            }
            else
            {
                error = 1;//如果 num2 为负数，设置 error 标志为 1，表示发生错误（不能对负数进行平方根运算）
            }
        }
        //进行加减乘除运算
        if (yun_flag == '+')
        {
            num1 = num1 + num2;
        }
        if (yun_flag == '-')
        {
            num1 = num1 - num2;
        }
        if (yun_flag == '*')
        {
            num1 = num1 * num2;
        }
        if (yun_flag == '/')
        {
            if (num2 != 0)//在执行除法前，检查 num2 是否为 0，防止除零错误。
            {
                num1 = num1 / num2;
            }
            else
            {
                error = 1;//若发现除0，则设置错误标志 error = 1。
            }
        }
        if (yun_flag == ' ' && num2 != 0)//当 yun_flag 为空格时，表示当前没有运算符。
        {
            num1 = num2;//如果没有运算符且 num2 不为 0，则将 num2 赋值给 num1。
        }
        num2 = 0;//运算完成后，将 num2 清零，为下一个输入做好准备
        sqrt_flag = 0;//重置平方根标志，表示本次开平方操作已经处理完毕
        neg_flag = 0;//重置负号标志，表示本次负数操作已经处理完毕
        pos_flag = 1;//重置小数点处理的标志
    }
    //按键处理
    if (keynum == 4)
    {
        yun_flag = '+';
    }
    if (keynum == 8)
    {
        yun_flag = '-';
    }
    if (keynum == 12)
    {
        yun_flag = '*';
    }
    if (keynum == 16)
    {
        yun_flag = '/';
    }
    /*
    keynum == 4：设置 yun_flag = '+'。
    keynum == 8：设置 yun_flag = '-'。
    keynum == 12：设置 yun_flag = '*'。
    keynum == 16：设置 yun_flag = '/'。
    */
    len = 0;//重置小数位数，准备接收新的数字输入
    key_last = 0;//标记运算符或操作键按下后，输入已经结束，等待新的输入
    refresh();//调用 refresh() 函数，更新屏幕上的显示内容，将 num1、num2 及运算符展示给用户
/*
1. len = 0;
len 用于记录当前输入的小数位数。在浮点数输入过程中，当用户输入了小数点并输入小数位时，len 会增加以跟踪当前输入了多少个小数位。例如，如果用户输入了 3.14，则 len 将被设置为 2，因为小数部分有两位。
在 operation 操作结束时，设置 len = 0 是为了重置小数位数，准备接收新的输入或下一次运算。通过将 len 重置为 0，系统可以确保用户开始新的输入时，不会受到之前输入的小数点的影响。

2. key_last = 0;
key_last 是一个标志变量，跟踪用户上一次按键输入的状态。当 key_last == 1 时，表示用户已经输入了一个数字键；当 key_last == 0 时，表示当前用户输入的是非数字键（如运算符或等号）。
在 operation 结束后，将 key_last 设置为 0 是为了表示当前输入已处理完毕，用户需要开始新的输入。例如，当用户按下运算符键（如 + 或 -）后，key_last 会被设置为 0，以确保接下来等待的输入是一个数字。
*/
}

void operation2(char keynum)
{
    float Data1;
/*
keynum == 1：表示数字7。
keynum == 2：表示数字8。
keynum == 3：表示数字9。
keynum == 5：表示数字4。
keynum == 6：表示数字5。
keynum == 7：表示数字6。
keynum == 9：表示数字1。
keynum == 10：表示数字2。
keynum == 11：表示数字3。
keynum == 13：表示数字0。
*/
    if (keynum == 1)
    {
        Data1 = 7;
    }
    if (keynum == 2)
    {
        Data1 = 8;
    }
    if (keynum == 3)
    {
        Data1 = 9;
    }
    if (keynum == 5)
    {
        Data1 = 4;
    }
    if (keynum == 6)
    {
        Data1 = 5;
    }
    if (keynum == 7)
    {
        Data1 = 6;
    }
    if (keynum == 9)
    {
        Data1 = 1;
    }
    if (keynum == 10)
    {
        Data1 = 2;
    }
    if (keynum == 11)
    {
        Data1 = 3;
    }
    if (keynum == 13)
    {
        Data1 = 0;
    }
    if (pos_flag == 1)//整数输入部分。当 pos_flag == 1 时，表示用户还没有输入小数点，此时输入的都是整数部分。
    {
        num2 = num2 * 10 + Data1;//将用户输入的数字 Data1 加到 num2 的末尾，构成新的整数。
        
    }
    else
    {
        num2 = num2 + (Data1 / pos_flag);
        //将当前输入的 Data1（即用户按下的数字键对应的数值）加到 num2 的小数部分中。通过 Data1 / pos_flag 将 Data1 放置在小数点后合适的位置。
        pos_flag = pos_flag * 10;//每输入一个小数位，pos_flag 被乘以 10，以便处理下一个小数位。
        len++;//len 用来记录小数点后的位数，每输入一位小数，len 递增。
    }
    key_last = 1;//key_last 表示用户按下了一个数字键，将其设置为 1 用来标记输入状态。在下一次输入时，系统可以根据 key_last 来判断这是新的输入。
    refresh();//调用函数刷新屏幕，将最新的 num2 值显示出来。
}

void operation3(void)
{
    if (pos_flag == 1)
    //pos_flag 用于追踪当前输入是否处于小数点之后的位置。
    //当 pos_flag == 1 时，表示用户尚未输入小数点，因此这个条件判断是在检测用户输入小数点的首次输入。    
    {
        pos_flag = pos_flag * 10;//如果用户输入了小数点，pos_flag 被乘以 10。这样每当用户输入一位小数时，新的小数位会被正确地处理。
        len++;//len 用来记录小数位的长度，每输入一位小数，len 会增加 1。这个变量帮助 refresh() 函数在屏幕上正确显示用户输入的小数部分。
    }
    key_last = 1;//这个标志 key_last 被设置为 1，表示上一个键是数字或相关输入。这用于跟踪计算器当前的输入状态，以便后续运算能正确处理。
    refresh();//调用 refresh() 函数来更新显示内容。每次用户输入新的数字或小数点后，显示屏的内容都会被刷新，以反映当前的输入情况。
}

void operation4(void)
{
    if (neg_flag == 1)
    //负号处理，如果 neg_flag 为 1，表示当前输入的数 num2 是负数。因此，将 num2 变为负数。
    //neg_flag 由 operation7() 提供
    {
        num2 = -num2;//取反操作，获得负数
    }
    if (sqrt_flag == 1)//开根号处理。如果 sqrt_flag 为 1，表示用户请求对 num2 求平方根。
    {
        if (num2 >= 0)//若 num2 非负，计算 num2 的平方根。
        {
            num2 = sqrt(num2);
        }
        else//若 num2 为负数，设置 error = 1，因为不能对负数求平方根。
        {
            error = 1;
        }
    }
    //加、减、乘、除处理。该部分与 operation1() 相同，在此不赘述
    if (yun_flag == '+')
    {
        num1 = num1 + num2;
    }
    if (yun_flag == '-')
    {
        num1 = num1 - num2;
    }
    if (yun_flag == '*')
    {
        num1 = num1 * num2;
    }
    if (yun_flag == '/')
    {
        if (num2 != 0)
        {
            num1 = num1 / num2;
        }
        else
        {
            error = 1;
        }
    }
    if (yun_flag == ' ' && num2 != 0)
    {
        num1 = num2;
    }
    num2 = 0;
    sqrt_flag = 0;
    neg_flag = 0;
    pos_flag = 1;
    yun_flag = ' ';//将 yun_flag 设为空，方便进行第二次计算
    len = 0;//重置小数长度
    key_last = 0;//标记运算结束，等待新的输入
    refresh();//重置LCD显示屏
}
/*
operation4(void)和operation1(char keynum)都定义了加减乘除，为什么要重复定义呢？

operation1(char keynum)：用于处理当用户按下加、减、乘、除运算符键时的操作。keynum 是代表按下的键值。
operation4(void)：用于处理当用户按下等号 = 键时的操作，没有参数。它执行的是最终的计算，将 num1 和 num2 结合当前运算符 yun_flag 进行运算。

因此，operation1() 负责在用户输入运算符时，立即执行上一次的运算。它充当了“中间步骤”的角色，让计算器能够正确处理连续的多步运算。
operation4() 负责在按下等号 = 时执行最终的运算。它不会立即在用户输入运算符时执行，而是在用户希望获得结果时，执行当前运算。
operation4() 是一个“终结步骤”，将所有先前的输入和运算符操作整合在一起。
*/

void operation5(void)
{
    num1 = 0;
    num2 = 0;
    sqrt_flag = 0;
    neg_flag = 0;
    pos_flag = 1;
    yun_flag = ' ';
    error = 0;
    len = 0;
    key_last = 0;
    refresh();
/*
逻辑：清除所有当前的输入和状态，重置变量和标志位。
num1 = 0; 和 num2 = 0; 清空当前存储的数字，为新的运算做准备。
sqrt_flag = 0; 和 neg_flag = 0; 重置平方根和负号标志，取消这些操作。
pos_flag = 1; 将小数位标志重置为 1，表示接下来的输入是整数部分。
yun_flag = ' '; 清空运算符，表示没有选择任何运算。
error = 0; 重置错误标志，表示没有错误。
len = 0; 重置小数位长度。
key_last = 0; 标志最近没有按下任何数字或运算符。
refresh(); 用于刷新显示
*/
}

void operation6(void)
{
    char i, length;//i：循环控制变量，用于遍历当前输入的数字字符串。length：存储当前 num2 转换为字符串后的长度。
    if (num2 == 0)//如果 num2 是 0，说明当前没有输入数字或数值已经清空。因此，所有标志位被重置
    {
        sqrt_flag = 0;
        neg_flag = 0;
        pos_flag = 1;
        len = 0;
        key_last = 0;
        refresh();
        return;
/*
sqrt_flag = 0; 清除平方根标志。
neg_flag = 0; 清除负号标志。
pos_flag = 1; 重置小数标志，准备处理整数输入。
len = 0; 清除小数部分的长度。
key_last = 0; 清除最后按键标志，等待新的输入。
refresh(); 清零LCD
*/
    }
    sprintf(c_num2, "%f", num2);
    //使用 sprintf() 函数将 num2 转换为字符串并存储在 c_num2 中，%f 表示以浮点数形式格式化输出。
    length = strlen(c_num2);
    //使用 strlen() 计算该字符串的长度，并将其存储在 length 中。
    for (i = length - 1; i >= 0; i--)//从字符串的末尾向前遍历
    {
        if (c_num2[i] != '0' && c_num2[i] != '.')//当找到既不是 '0' 也不是 '.' 的字符时，循环立即终止。
        {
            break;//一旦找到了符合条件的字符，语句立即终止循环，此时 i 保存的就是该有效数字或小数点前的字符的索引。
        }
    }
    if (pos_flag == 1)//如果 pos_flag == 1，表示当前处理的是整数部分
    {
        num2 -= (c_num2[i] - '0');//将最后一位有效数字从 num2 中减去
        num2 = num2 / 10;//并将 num2 除以 10，达到删除该数字的效果
    }
    else//若 pos_flag != 1，表示当前处理的是小数部分
    {
        pos_flag /= 10;
        //在处理小数时用于控制小数位数，当按下退格键时，将 pos_flag 除以 10，这样就相当于减少一位小数的精度。
        //例如两位小数则 pos_flag = 10，三位则 pos_flag = 100
        num2 *= pos_flag;
        //将 num2 乘以当前的 pos_flag，将小数部分转换为整数形式。例如：
        //例如当 num2 = 12.34 且 pos_flag = 100，此时 num2 会被转换为 1234，方便删除最后一位 4。 
        num2 -= (c_num2[i] - '0');//将最后一位有效数字从 num2 中减去
        num2 /= pos_flag;
        //将数值除以 pos_flag，将之前放大的整数还原为小数形式
        //例如当前数值是 1230，pos_flag = 100，还原后得到 12.30（即删除了最后一位 4）
        len--;//减少小数部分的位数计数，用于控制小数点后的显示和进一步的输入处理。
    }
    refresh();//刷新LCD显示
}
/*
如何理解 num2 -= (c_num2[i] - '0');

1.首先，我们使用了一个 for 循环从字符串的末尾向前遍历，找到我们需要删除（退位）的最后一个数。
    for (i = length - 1; i >= 0; i--)
    if (c_num2[i] != '0' && c_num2[i] != '.')
    {
        break;
    }
for 循环在每次迭代时，i 的值都会减少 1，直到循环条件不再成立（i >= 0）或遇到 break 语句。
一旦满足 if 条件（即 c_num2[i] != '0' && c_num2[i] != '.'），循环立即停止，程序执行 break 跳出循环，此时 i 保留了当前的索引值。
因此当 break 执行时，i 的值就是满足 if 条件的那一刻的 i，即最后一个既不是 '0' 也不是 '.' 的字符的索引。在 break 之后，i 存储了这个有效数字的索引。
在代码开头，我们就已经定义了 char i 这个变量，因此 i 在 break 之后存储了这个数组的最后一个既不是 '0' 也不是 '.'的数。
我们以 123456 举例，该数组通过 for 循环后，最后一位为 6，因此此时 i = 6

2.c_num2 是通过 sprintf 函数将浮点数 num2 转换为字符串表示的字符数组。例如，此时 num2 是 123456，c_num2 的内容则为 "123456"。
c_num2[i] 为表示字符形式的某一位数字。在上面的 i 定义中，i = 6，所以此时 c_num2[i] 为字符 '6'。

3.字符 '0' 的 ASCII 值是 48，那么我们查表可知0~9的所有ASCII编码值：0=48;1=49;2=50;3=51;4=52;5=53;6=54;7=55;8=56;9=57
透过ASCII表可知，因为此时编码的数字字符是连续的，所以减去 '0' 的 ASCII 值就能将字符 '0' 到 '9' 转换为数值 0 到 9。例如，字符 '5' 的 ASCII 值是 53，而 '0' 的 ASCII 值是 48，'5' - '0' = 53 - 48 = 5。
回到我们的例子，此时 i = 6 ，所以 c_num2[6] = 54，c_num2[i] - '0' 的作用是将字符数字转换为整数，所以 c_num2[6] - '0'= 54 - 48 = 6。

4.从 num2 中减去最后一位数字。num2 - = (c_num2[i] - '0'); 这一步的作用是从 num2 中减去数值 (c_num2[i] - '0') 计算出的数值。
在我们的例子中 num2 = 123456，(c_num2[i] - '0')计算出的数值为 6，这一步操作后，num2 将变为 123450（即 123456 - 6 = 123450）。

5.在这之后，num2 还会被除以 10，从而彻底移除最后一位有效数字。所以此时 123450 将被除以 10 ，变成 12345 ，完成退位。
*/

void operation7(void)
{
    if (neg_flag == 0)//如果 neg_flag 为 0，表示当前数字是正数，按下 +/- 键后，neg_flag 被设置为 1，将数字变为负数。
    {
        neg_flag = 1;
    }
    else//如果 neg_flag 已经为 1，表示当前数字是负数，按下 +/- 键后，neg_flag 被设置为 0，将数字变为正数。
    {
        neg_flag = 0;
    }
    key_last = 1;//设置 key_last = 1，表示这一次按键是与数字输入相关的操作。在后续的运算或输入处理中有助于区分最近的操作是数字输入还是运算符输入。
    refresh();
}

void operation8(void)
{
    if (sqrt_flag == 0)//sqrt_flag 是一个控制平方根功能的标志变量，判断当前 sqrt_flag 是否为 0。如果为 0，则表示平方根功能未启用。
    {
        sqrt_flag = 1;//如果 sqrt_flag 原本是 0（未启用），将其设置为 1（启用平方根功能）。
    }
    else
    {
        sqrt_flag = 0;//如果 sqrt_flag 原本是 1（已启用），执行 else 代码块，将其重置为 0，关闭平方根功能。
    }
    key_last = 1;//该语句的作用是记录最近一次按键操作的状态，用于确认平方根开启或关闭。
    refresh();
}

//==========================按键处理函数：根据 keynum 值执行不同操作，使用 switch 语句匹配并调用相应函数。==========================//

/*
这个函数通过接收按键输入（keynum），根据按键的值执行不同的操作。这段代码使用 switch 语句来匹配按键值，并调用不同的函数来执行相应的操作。
代码简单，因此直接使用块注释

switch (keynum)：根据按键编号 keynum 来匹配具体的按键功能。每个按键 keynum 都对应不同的操作。
第一组按键：4, 8, 12, 16；调用 operation1(keynum)。
第二组按键：1, 2, 3, 5, 6, 7, 9, 10, 11, 13；调用 operation2(keynum) 函数。
第三组按键：14：调用 operation3(void)
第四组按键：15：调用 operation4(void)
第五组按键：17：调用 operation5(void)
第六组按键：18：调用 operation6(void)
第七组按键：19：调用 operation7(void)
第八组按键：20：调用 operation8(void)

前提条件：只有在 error == 0 时才执行该操作，即当没有发生错误时才能操作
*/
void key(char keynum)
{
    switch (keynum)
    {
        //=======第一组=======
        case 4 :
        case 8 :
        case 12:
        case 16:
        {
            if (error == 0)
            {
                operation1(keynum);
            }
            break;
        }
        //=======第二组=======
        case 1  :
        case 2  :
        case 3  :
        case 5  :
        case 6  :
        case 7  :
        case 9  :
        case 10 :
        case 11 :
        case 13 :
        {
            if (error == 0)
            {
                operation2(keynum);
            }
            break;
        }
        //=======第三组=======
        case 14 :
        {
            if (error == 0)
            {
                operation3();
            }
            break;
        }
        //=======第四组=======
        case 15 :
        {
            if (error == 0)
            {
                operation4();
            }
            break;
        }
        //=======第五组=======
        case 17 :
        {
            operation5();
            break;
        }
        //=======第六组=======
        case 18 :
        {
            if (error == 0)
            {
                operation6();
            }
            break;
        }
        //=======第七组=======
        case 19 :
        {
            if (error == 0)
            {
                operation7();
            }
            break;
        }
        //=======第八组=======
        case 20 :
        {
            if (error == 0)
            {
                operation8();
            }
            break;
        }
    }
}

//========================== main 主函数==========================//

void main(void)//计算器主函数
{
    InitLcd();//调用 InitLcd() 函数初始化 LCD 屏幕。这个函数会设置 LCD 的硬件连接、控制寄存器等内容，确保屏幕可以正常显示。
    DelayMs(15);//调用 DelayMs(15) 函数，延迟 15 毫秒。延迟的主要目的是确保在初始化硬件之后，有足够的时间让硬件设备稳定下来。
    refresh();//调用 refresh() 函数刷新显示。
    while (1)//主循环，while (1) 负责创建一个无限循环，程序会一直运行，直到手动停止或关闭电源。
    {
        key(scan());//根据用户的输入，key() 函数会调用不同的 operation 函数进行处理
    }
}


/*
 5x4 矩阵键盘布局及功能说明：

|    7     |    8     |    9     |    +     |
|    4     |    5     |    6     |    -     |
|    1     |    2     |    3     |    *     |
|    0     |    .     |    =     |    /     |
|    C     |    <     |    +/-   |    √     |

*/